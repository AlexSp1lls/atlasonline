"use strict";
var types = require("@sanity/types"), util_reverseSelection = require("./util.reverse-selection.cjs"), selector_isAtTheStartOfBlock = require("./selector.is-at-the-start-of-block.cjs");
const getTrimmedSelection = ({
  context
}) => {
  if (!context.selection)
    return context.selection;
  const startPoint = selector_isAtTheStartOfBlock.getSelectionStartPoint({
    context
  }), endPoint = selector_isAtTheStartOfBlock.getSelectionEndPoint({
    context
  });
  if (!startPoint || !endPoint)
    return context.selection;
  const startBlockKey = util_reverseSelection.isKeyedSegment(startPoint.path[0]) ? startPoint.path[0]._key : null, startChildKey = util_reverseSelection.isKeyedSegment(startPoint.path[2]) ? startPoint.path[2]._key : null, endBlockKey = util_reverseSelection.isKeyedSegment(endPoint.path[0]) ? endPoint.path[0]._key : null, endChildKey = util_reverseSelection.isKeyedSegment(endPoint.path[2]) ? endPoint.path[2]._key : null;
  if (!startBlockKey || !endBlockKey)
    return context.selection;
  let startBlockFound = !1, adjustedStartPoint, trimStartPoint = !1, adjustedEndPoint, trimEndPoint = !1, previousPotentialEndpoint;
  for (const block of context.value)
    if (!(block._key === startBlockKey && (startBlockFound = !0, types.isPortableTextTextBlock(block) && util_reverseSelection.isEmptyTextBlock(block))) && startBlockFound && types.isPortableTextTextBlock(block)) {
      if (block._key === endBlockKey && util_reverseSelection.isEmptyTextBlock(block))
        break;
      for (const child of block.children) {
        if (child._key === endChildKey && (!types.isPortableTextSpan(child) || endPoint.offset === 0)) {
          adjustedEndPoint = previousPotentialEndpoint ? {
            path: [{
              _key: previousPotentialEndpoint.blockKey
            }, "children", {
              _key: previousPotentialEndpoint.span._key
            }],
            offset: previousPotentialEndpoint.span.text.length
          } : void 0, trimEndPoint = !0;
          break;
        }
        if (trimStartPoint) {
          const lonelySpan = types.isPortableTextSpan(child) && block.children.length === 1;
          (types.isPortableTextSpan(child) && child.text.length > 0 || lonelySpan) && (adjustedStartPoint = {
            path: [{
              _key: block._key
            }, "children", {
              _key: child._key
            }],
            offset: 0
          }, previousPotentialEndpoint = {
            blockKey: block._key,
            span: child
          }, trimStartPoint = !1);
          continue;
        }
        if (child._key === startChildKey) {
          if (!types.isPortableTextSpan(child)) {
            trimStartPoint = !0;
            continue;
          }
          if (startPoint.offset === child.text.length) {
            trimStartPoint = !0, previousPotentialEndpoint = child.text.length > 0 ? {
              blockKey: block._key,
              span: child
            } : previousPotentialEndpoint;
            continue;
          }
        }
        previousPotentialEndpoint = types.isPortableTextSpan(child) && child.text.length > 0 ? {
          blockKey: block._key,
          span: child
        } : previousPotentialEndpoint;
      }
      if (block._key === endBlockKey)
        break;
    }
  const trimmedSelection = context.selection.backward ? {
    anchor: trimEndPoint && adjustedEndPoint ? adjustedEndPoint : endPoint,
    focus: adjustedStartPoint ?? startPoint,
    backward: !0
  } : {
    anchor: adjustedStartPoint ?? startPoint,
    focus: trimEndPoint && adjustedEndPoint ? adjustedEndPoint : endPoint
  };
  if (selector_isAtTheStartOfBlock.isSelectionCollapsed({
    context: {
      ...context,
      selection: trimmedSelection
    }
  })) {
    const focusTextBlock = selector_isAtTheStartOfBlock.getFocusTextBlock({
      context: {
        ...context,
        selection: trimmedSelection
      }
    });
    if (focusTextBlock && !util_reverseSelection.isEmptyTextBlock(focusTextBlock.node))
      return null;
  }
  return trimmedSelection;
};
exports.getTrimmedSelection = getTrimmedSelection;
//# sourceMappingURL=selector.get-trimmed-selection.cjs.map
