{"version":3,"file":"selector.get-trimmed-selection.cjs","sources":["../../src/selectors/selector.get-trimmed-selection.ts"],"sourcesContent":["import {\n  isPortableTextSpan,\n  isPortableTextTextBlock,\n  type PortableTextSpan,\n} from '@sanity/types'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport type {EditorSelection, EditorSelectionPoint} from '../types/editor'\nimport {isEmptyTextBlock, isKeyedSegment} from '../utils'\nimport {getSelectionEndPoint} from './selector.get-selection-end-point'\nimport {getSelectionStartPoint} from './selector.get-selection-start-point'\nimport {isSelectionCollapsed} from './selector.is-selection-collapsed'\nimport {getFocusTextBlock} from './selectors'\n\n/**\n * @public\n */\nexport const getTrimmedSelection: EditorSelector<EditorSelection> = ({\n  context,\n}) => {\n  if (!context.selection) {\n    return context.selection\n  }\n\n  const startPoint = getSelectionStartPoint({context})\n  const endPoint = getSelectionEndPoint({context})\n\n  if (!startPoint || !endPoint) {\n    return context.selection\n  }\n\n  const startBlockKey = isKeyedSegment(startPoint.path[0])\n    ? startPoint.path[0]._key\n    : null\n  const startChildKey = isKeyedSegment(startPoint.path[2])\n    ? startPoint.path[2]._key\n    : null\n  const endBlockKey = isKeyedSegment(endPoint.path[0])\n    ? endPoint.path[0]._key\n    : null\n  const endChildKey = isKeyedSegment(endPoint.path[2])\n    ? endPoint.path[2]._key\n    : null\n\n  if (!startBlockKey || !endBlockKey) {\n    return context.selection\n  }\n\n  let startBlockFound = false\n  let adjustedStartPoint: EditorSelectionPoint | undefined\n  let trimStartPoint = false\n  let adjustedEndPoint: EditorSelectionPoint | undefined\n  let trimEndPoint = false\n  let previousPotentialEndpoint:\n    | {blockKey: string; span: PortableTextSpan}\n    | undefined\n\n  for (const block of context.value) {\n    if (block._key === startBlockKey) {\n      startBlockFound = true\n\n      if (isPortableTextTextBlock(block) && isEmptyTextBlock(block)) {\n        continue\n      }\n    }\n\n    if (!startBlockFound) {\n      continue\n    }\n\n    if (!isPortableTextTextBlock(block)) {\n      continue\n    }\n\n    if (block._key === endBlockKey && isEmptyTextBlock(block)) {\n      break\n    }\n\n    for (const child of block.children) {\n      if (child._key === endChildKey) {\n        if (!isPortableTextSpan(child) || endPoint.offset === 0) {\n          adjustedEndPoint = previousPotentialEndpoint\n            ? {\n                path: [\n                  {_key: previousPotentialEndpoint.blockKey},\n                  'children',\n                  {_key: previousPotentialEndpoint.span._key},\n                ],\n                offset: previousPotentialEndpoint.span.text.length,\n              }\n            : undefined\n\n          trimEndPoint = true\n          break\n        }\n      }\n\n      if (trimStartPoint) {\n        const lonelySpan =\n          isPortableTextSpan(child) && block.children.length === 1\n\n        if (\n          (isPortableTextSpan(child) && child.text.length > 0) ||\n          lonelySpan\n        ) {\n          adjustedStartPoint = {\n            path: [{_key: block._key}, 'children', {_key: child._key}],\n            offset: 0,\n          }\n          previousPotentialEndpoint = {blockKey: block._key, span: child}\n          trimStartPoint = false\n        }\n\n        continue\n      }\n\n      if (child._key === startChildKey) {\n        if (!isPortableTextSpan(child)) {\n          trimStartPoint = true\n          continue\n        }\n\n        if (startPoint.offset === child.text.length) {\n          trimStartPoint = true\n          previousPotentialEndpoint =\n            child.text.length > 0\n              ? {blockKey: block._key, span: child}\n              : previousPotentialEndpoint\n          continue\n        }\n      }\n\n      previousPotentialEndpoint =\n        isPortableTextSpan(child) && child.text.length > 0\n          ? {blockKey: block._key, span: child}\n          : previousPotentialEndpoint\n    }\n\n    if (block._key === endBlockKey) {\n      break\n    }\n  }\n\n  const trimmedSelection = context.selection.backward\n    ? {\n        anchor: trimEndPoint && adjustedEndPoint ? adjustedEndPoint : endPoint,\n        focus: adjustedStartPoint ?? startPoint,\n        backward: true,\n      }\n    : {\n        anchor: adjustedStartPoint ?? startPoint,\n        focus: trimEndPoint && adjustedEndPoint ? adjustedEndPoint : endPoint,\n      }\n\n  if (\n    isSelectionCollapsed({\n      context: {\n        ...context,\n        selection: trimmedSelection,\n      },\n    })\n  ) {\n    const focusTextBlock = getFocusTextBlock({\n      context: {\n        ...context,\n        selection: trimmedSelection,\n      },\n    })\n\n    if (focusTextBlock && !isEmptyTextBlock(focusTextBlock.node)) {\n      return null\n    }\n  }\n\n  return trimmedSelection\n}\n"],"names":["getTrimmedSelection","context","selection","startPoint","getSelectionStartPoint","endPoint","getSelectionEndPoint","startBlockKey","isKeyedSegment","path","_key","startChildKey","endBlockKey","endChildKey","startBlockFound","adjustedStartPoint","trimStartPoint","adjustedEndPoint","trimEndPoint","previousPotentialEndpoint","block","value","isPortableTextTextBlock","isEmptyTextBlock","child","children","isPortableTextSpan","offset","blockKey","span","text","length","undefined","lonelySpan","trimmedSelection","backward","anchor","focus","isSelectionCollapsed","focusTextBlock","getFocusTextBlock","node"],"mappings":"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"}